#!/usr/bin/env python3

"""
sysmon - a SYStem MONitor written in python, designed to be easy
to understand, and "ready to use", without installing dependecies (except curses)

made by dev64 (also known as .dev, devlocalhost)
"""


import os
import sys
import glob
import time
import curses
import argparse
import subprocess

from datetime import datetime


parser = argparse.ArgumentParser()
parser.add_argument(
    "--nocpu",
    action="store_true",
    help="Disables cpuinfo (cpu information, like usage, model, and more)",
)
parser.add_argument(
    "--nomem",
    action="store_true",
    help="~~~~~~~~ meminfo (memory information, like total, used and more)",
)
parser.add_argument(
    "--noload",
    action="store_true",
    help="~~~~~~~~ loadavg (load times information, including uptime)",
)
parser.add_argument(
    "--nopid",
    action="store_true",
    help="~~~~~~~~ procpid (most ram/vmrss consuming pids)",
)
parser.add_argument(
    "--nonet",
    action="store_true",
    help="~~~~~~~~ network_stats (network stats, like received/transfered bytes)",
)

args = parser.parse_args()

# sysmon basic functions start


def char_padding(char, value):
    """
    return char value times
    """

    return char * value


def convert_bytes(fsize, units=(" bytes", " KiB", " MiB", " GiB", " TiB")):
    """convert bytes to k, m, g and t"""

    return (
        f"{float(fsize):.2f}{units[0]}"
        if fsize < 1024
        else convert_bytes(fsize / 1024, units[1:])
    )


def en_open(file, method="r"):
    """modifying the default open method so i dont have to define encoding every time"""
    return open(file, method, encoding="utf-8")


def detect_network_adapter():
    """detect an active network adapter/card/whatever and return its directory"""
    adp_directory = None

    for adapter_dir in glob.glob("/sys/class/net/*"):
        with en_open(adapter_dir + "/type") as device_type:
            if int(device_type.read()) != 772:  # if not loopback device

                with en_open(adapter_dir + "/operstate") as status:
                    if status.read().replace("\n", "") == "up":
                        adp_directory = adapter_dir

    return adp_directory


def file_has(string, lines):
    """checking if file contains string. return string if contains else return None"""

    has_string = None

    for line in lines:
        if line.startswith(string):
            has_string = line.replace("\t", "").split(":")[1]

    return has_string


def clean_output(text):
    """
    cleans the output that sysmon reads, so it gets only 1005744
    instead of MemTotal:        1005744 kB
    """

    return text.split(":")[0].replace(" ", "").replace("\n", "").replace("kB", "")


def to_bytes(kilobytes):
    """convert kilobytes to bytes"""

    return kilobytes * 1024


def uptime_format(seconds):
    """format the uptime from seconds to a human readable format"""

    intervals = (("weeks", 604800), ("days", 86400), ("hours", 3600), ("minutes", 60))
    result = []

    for name, count in intervals:
        value = seconds // count

        if value:
            seconds -= value * count

            if value == 1:
                name = name.rstrip("s")

            result.append(f"{value} {name}")

    return ", ".join(result)


def clean_cpu_model(model):
    """cleaning cpu model"""
    replace_stuff = [
        "(R)",
        "(TM)",
        "(tm)",
        "Processor",
        "processor",
        '"AuthenticAMD"',
        "Chip Revision",
        "Technologies, Inc",
        "CPU",
    ]

    for text in replace_stuff:
        model = model.replace(text, "")

    return " ".join(model.split()).split("@", maxsplit=1)[0].rstrip(" ")


# sysmon basic functions end

# sysmon cpu


def cpu_usage():
    """
    /proc/stat - cpu usage of the system
    """
    os.makedirs("/tmp/sysmon_save", exist_ok=True)

    try:
        if not os.path.exists("/tmp/sysmon_save/cpu_old_data"):
            with en_open("/tmp/sysmon_save/cpu_old_data", "a") as temp_file:
                temp_file.write("cpu.758102.17.259220.2395399.122421.3.1284")

        with en_open("/tmp/sysmon_save/cpu_old_data") as old_stats:
            old_stats = old_stats.readline().split(".")
            previous_data = (
                int(old_stats[1])
                + int(old_stats[2])
                + int(old_stats[3])
                + int(old_stats[6])
                + int(old_stats[7])
            )

        with en_open("/proc/stat") as new_stats:
            new_stats = (
                new_stats.readline().replace("cpu ", "cpu").replace("\n", "").split(" ")
            )

            current_data = (
                int(new_stats[1])
                + int(new_stats[2])
                + int(new_stats[3])
                + int(new_stats[6])
                + int(new_stats[7])
            )

        total = sum(map(int, old_stats[1:])) - sum(map(int, new_stats[1:]))

        with en_open("/tmp/sysmon_save/cpu_old_data", "w") as update_data:
            update_data.write(".".join(new_stats))

        return round(100 * ((previous_data - current_data) / total))

    except FileNotFoundError:
        sys.exit("Couldnt find /proc/stat file")

    except PermissionError:
        sys.exit(
            "Couldnt read the file. Do you have read permissions for /proc/stat file?"
        )


def cpu_temp():
    """
    getting the cpu temperature from /sys/class/hwmon
    """

    temperature = "!?"

    for temp_dir in glob.glob("/sys/class/hwmon/*"):
        with en_open(temp_dir + "/name") as temp_type:
            if (temp_type.read() in "coretemp", "fam15h_power", "k10temp", "acpitz"):
                try:
                    with en_open(temp_dir + "/temp1_input") as temp_value:
                        temperature = int(int(temp_value.read().strip()) / 1000)

                except (FileNotFoundError, OSError):
                    pass

    return temperature


def cpuinfo():
    """
    /proc/cpuinfo - cpu information
    """

    try:
        with en_open("/proc/cpuinfo") as cpuinfo_file:
            read_file = cpuinfo_file.readlines()

            cpu_freq = file_has("cpu MHz", read_file).replace("\n", "").replace(" ", "")

            model = clean_cpu_model(file_has("model name", read_file))
            cache_size = (
                file_has("cache size", read_file)
                .replace(" ", "")
                .replace("\n", "")
                .replace("KB", "")
            )
            architecture = subprocess.check_output(
                "uname -m", shell=True, text=True
            ).replace("\n", "")

            try:
                total_cores = (
                    file_has("cpu cores", read_file).replace(" ", "").replace("\n", "")
                )

            except AttributeError:
                total_cores = subprocess.check_output(
                    "nproc", shell=True, text=True
                ).replace("\n", "")

            try:
                total_threads = (
                    file_has("siblings", read_file).replace(" ", "").replace("\n", "")
                )

            except AttributeError:
                total_threads = subprocess.check_output(
                    "nproc --all", shell=True, text=True
                ).replace("\n", "")

            cpu_usage_num = cpu_usage()
            cpu_temperature = str(cpu_temp())

            arch_model_temp_line = f"| {architecture} {model}\n"

            # yes very long name i know. i can make it shorter but
            # ... no. it would be some randon chars like aml_line lol

            if cpu_temperature != "!?":
                cpu_temperature += " Â°C"
                arch_model_temp_line = f"({cpu_temperature}) " + arch_model_temp_line

        return (
            f"  --- /proc/cpuinfo {char_padding('-', 47)}\n"
            f"{char_padding(' ', 11)}Usage: {cpu_usage_num}% "
            + " " * (3 - len(str(cpu_usage_num)))
            + arch_model_temp_line
            + f"   Cores/Threads: {total_cores}/{total_threads} @ {cpu_freq} MHz"
            f" with {convert_bytes(to_bytes(int(cache_size)))} cache memory\n"
        )

    except FileNotFoundError:
        sys.exit("Couldnt find /proc/cpuinfo file")

    except PermissionError:
        sys.exit(
            "Couldnt read the file. Do you have read permissions for /proc/cpuinfo file?"
        )


# sysmon cpu

# sysmon loadavg


def loadavg():
    """
    /proc/loadavg - system load times and uptime
    """

    try:
        uptime_fmt = "Unknown"

        with en_open("/proc/loadavg") as load_times_file:
            load_times_data = load_times_file.read()

            onemin = load_times_data.split(" ")[0]
            fivemin = load_times_data.split(" ")[1]
            fiveteenmin = load_times_data.split(" ")[2]
            threadactive = load_times_data.split(" ")[3].split("/")[0]
            threadtotal = load_times_data.split(" ")[3].split("/")[1]

        with open("/proc/uptime", encoding="utf-8") as uptime_file:
            uptime_data = uptime_file.read()
            uptime_secs = int(uptime_data.split(".", maxsplit=1)[0])

        if uptime_secs < 60:
            uptime_fmt = f"{uptime_secs} seconds"

        else:
            uptime_fmt = uptime_format(int(uptime_data.split(".", maxsplit=1)[0]))

        up_since_fmt = datetime.fromtimestamp(
            int(str(time.time()).split(".", maxsplit=1)[0]) - int(uptime_secs)
        ).strftime("%A %B %d %Y, %I:%M:%S %p")

        return (
            f"  --- /proc/loadavg {char_padding('-', 47)}\n"
            f"   System load: {onemin}, {fivemin}, {fiveteenmin} (1, 5, 15 mins)\n"
            f"       Threads: {threadactive} active, {threadtotal} total"
            f"\n\n   System up for {uptime_fmt}\n    Since {up_since_fmt}\n"
        )

    except FileNotFoundError:
        sys.exit("Couldnt find /proc/loadavg file")

    except PermissionError:
        sys.exit(
            "Couldnt read the file. Do you have read permissions for /proc/loadavg file?"
        )


# sysmon loadavg

# sysmon procpid


def procpid():
    """
    return the most ram (vmrss) consuming pids, with their state and name
    """

    processes = []

    procs = glob.glob("/proc/*/status")

    if not procs:
        procs = ["sugoma"]

    for proc_status in procs:
        try:
            with en_open(proc_status) as status_file:
                s_readlines = status_file.readlines()

                pid_name = clean_output(file_has("Name:", s_readlines))
                pid_num = proc_status.split("/")[2]

                try:
                    rss = clean_output(file_has("VmRSS", s_readlines))

                except AttributeError:
                    rss = "!?"

                try:
                    state_field = file_has("State:", s_readlines)
                    state = state_field[
                        state_field.index("(") + 1 : state_field.index(")")
                    ].title()

                except AttributeError:
                    state = "!?"

                if rss != "!?":
                    processes.append(
                        f"{pid_name},{to_bytes(int(rss))},{state},{pid_num}"
                    )

        except FileNotFoundError:
            processes.append("!?!?,76328097200209,!?!?!,64")

    processes.sort(key=lambda a: float(a.split(",")[1]), reverse=True)

    formatted_data = [
        f"  --- /proc/pid/* {char_padding('-', 49)}\n   Name            PID   RSS            State"
    ]

    for proc_item in processes[:6]:
        data = proc_item.split(",")

        name, rss_usage, pstate, pid = (
            data[0],
            convert_bytes(int(data[1])),
            data[2],
            data[3][:5],
        )

        formatted_data.append(
            f"   {name}{char_padding(' ', (15 - len(name)))} "
            f"{pid}{char_padding(' ', (5 - len(pid)))} "
            f"{rss_usage}{char_padding(' ', (14 - len(rss_usage)))} {pstate}"
        )

    return "\n".join(formatted_data) + "\n"


# sysmon procpid

# sysmon meminfo


def meminfo():
    """
    /proc/meminfo - system memory (ram) and swap information
    """

    try:
        with open("/proc/meminfo", encoding="utf-8") as meminfo_file:
            meminfo_data = meminfo_file.readlines()

            memory_total = to_bytes(
                int(clean_output(file_has("MemTotal", meminfo_data)))
            )
            memory_available = to_bytes(
                int(clean_output(file_has("MemAvailable", meminfo_data)))
            )
            memory_cached = to_bytes(
                int(clean_output(file_has("Cached", meminfo_data)))
            )

            memory_used = round(memory_total - memory_available)

            memory_used_percent = round((int(memory_used) / int(memory_total)) * 100, 1)
            memory_available_percent = round(100 - memory_used_percent, 1)

            if to_bytes(int(clean_output(file_has("SwapTotal", meminfo_data)))) != 0:
                swap_total = to_bytes(
                    int(clean_output(file_has("SwapTotal", meminfo_data)))
                )
                swap_available = to_bytes(
                    int(clean_output(file_has("SwapFree", meminfo_data)))
                )
                swap_cached = to_bytes(
                    int(clean_output(file_has("SwapCached", meminfo_data)))
                )

                swap_used = round(swap_total - swap_available)

                swap_used_percent = round((int(swap_used) / int(swap_total)) * 100, 1)
                swap_available_percent = round(100 - swap_used_percent, 1)

                memory_used_format = (
                    f"{convert_bytes(memory_used)} ({memory_used_percent}%)"
                )
                memory_avail_format = (
                    f"{convert_bytes(memory_available)} "
                    f"({memory_available_percent}%)"
                )

                # spaghetti code incoming

                spaces_swap = 24

                if str(convert_bytes(swap_total)).split(" ")[1] == "GiB":
                    spaces_swap = 23

                elif str(convert_bytes(swap_total)).split(" ")[1] == "TiB":
                    spaces_swap = 22


                return (
                    f"  --- /proc/meminfo {char_padding('-', 47)}\n"
                    f"   RAM: {char_padding(' ', 25)} Swap:\n"
                    f"        Total: {convert_bytes(memory_total)}"
                    + char_padding(" ", (spaces_swap - len(convert_bytes(swap_total))))
                    + f"Total: {convert_bytes(swap_total)}\n"
                    f"         Used: {memory_used_format}"
                    + char_padding(" ", (26 - len(memory_used_format)))
                    + f"Used: {convert_bytes(swap_used)} ({swap_used_percent}%)\n"
                    f"    Available: {memory_avail_format}"
                    + char_padding(" ", (21 - len(memory_avail_format)))
                    + f"Available: {convert_bytes(swap_available)} ({swap_available_percent}%)\n"
                    f"       Cached: {convert_bytes(memory_cached)}"
                    + char_padding(" ", (24 - len(convert_bytes(memory_cached))))
                    + f"Cached: {convert_bytes(swap_cached)}\n"
                )

            return (
                f"  --- /proc/meminfo {char_padding('-', 47)}\n"
                f"   RAM: {char_padding(' ', 25)} Swap: Disabled or not available\n"
                f"        Total: {convert_bytes(memory_total)}\n"
                f"         Used: {convert_bytes(memory_used)} ({memory_used_percent}%)\n"
                f"    Available: {convert_bytes(memory_available)} ({memory_available_percent}%)\n"
                f"       Cached: {convert_bytes(memory_cached)}\n"
            )

    except FileNotFoundError:
        sys.exit("Couldnt find /proc/meminfo file")

    except PermissionError:
        sys.exit(
            "Couldnt read the file. Do you have read permissions for /proc/meminfo file?"
        )


# sysmon meminfo

# sysmon net


def network_stats():
    """
    /sys/class/net/ - network stats, and speed
    """

    adapter_directory = detect_network_adapter()

    if adapter_directory is not None:
        os.makedirs("/tmp/sysmon_save", exist_ok=True)
        save_directory = "/tmp/sysmon_save/"

        if not os.path.isfile(f"{save_directory}rx") and not os.path.isfile(
            f"{save_directory}tx"
        ):
            with en_open(f"{save_directory}rx", "w") as rx_file:
                rx_file.write("0")

            with en_open(f"{save_directory}tx", "w") as tx_file:
                tx_file.write("0")

        with en_open(adapter_directory + "/statistics/rx_bytes") as received:
            received = int(received.read().replace("\n", ""))

        with en_open(adapter_directory + "/statistics/tx_bytes") as transferred:
            transferred = int(transferred.read().replace("\n", ""))

        with en_open(f"{save_directory}rx") as recv_speed:
            recv_speed = abs(int(recv_speed.read().replace("\n", "")) - received)

        with en_open(f"{save_directory}tx") as transf_speed:
            transf_speed = abs(int(transf_speed.read().replace("\n", "")) - transferred)

        with en_open(f"{save_directory}rx", "w") as rxsave:
            rxsave.write(str(received))

        with en_open(f"{save_directory}tx", "w") as txsave:
            txsave.write(str(transferred))

        human_received = convert_bytes(received)
        human_transferred = convert_bytes(transferred)

        return (
            f"  --- /sys/class/net {char_padding('-', 46)}\n"
            f"        Device: {adapter_directory.split('/')[4]}\n"
            f"      Received: {human_received}"
            + char_padding(" ", (14 - len(human_received)))
            + f"({received} bytes)\n"
            f"   Transferred: {human_transferred}"
            + char_padding(" ", (14 - len(human_transferred)))
            + f"({transferred} bytes)\n"
            f"         Speed: Down {convert_bytes(recv_speed)}"
            + char_padding(" ", (14 - len(convert_bytes(recv_speed))))
            + f"| Up {convert_bytes(transf_speed)}\n"
        )

    return f"  --- /sys/class/net/!?!? {char_padding('-', 41)}\n"


# sysmon net

func_dict = {
    "cpu": cpuinfo,
    "mem": meminfo,
    "load": loadavg,
    "pid": procpid,
    "net": network_stats,
}


def main(print_out):
    """main printing method, what you see when you run sysmon"""

    curses.curs_set(0)
    curses.use_default_colors()

    while True:
        print_out.addstr(
            f" --- Sysmon | {datetime.now().strftime('%I:%M:%S %p')} " + "-" * 42 + "\n"
        )

        for name, function in func_dict.items():
            if not getattr(args, "no" + name, False):
                print_out.addstr(function())

        print_out.addstr(f" {'-' * 67}")

        print_out.refresh()
        print_out.clear()
        time.sleep(1)


curses.wrapper(main)
