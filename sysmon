#!/usr/bin/env python3

"""
sysmon - a SYStem MONitor written in python, designed to be easy
to understand, and "ready to use", without installing dependecies (except curses)

made by dev64 (also known as .dev, devlocalhost)
"""


import os
import sys
import glob
import time
import curses
import select
import platform
import argparse
import multiprocessing

from datetime import datetime

SAVE_DIR = None
hwmon_dirs_out = glob.glob("/sys/class/hwmon/*")

try:
    os.makedirs("/tmp/sysmon_save", exist_ok=True)
    SAVE_DIR = "/tmp/sysmon_save"

except OSError:
    os.makedirs(".sysmon_save", exist_ok=True)
    SAVE_DIR = ".sysmon_save"

formatter = lambda prog: argparse.HelpFormatter(prog, max_help_position=40)
parser = argparse.ArgumentParser(formatter_class=formatter)
parser.add_argument(
    "-nc",
    "--nocpu",
    action="store_true",
    help="disables cpuinfo (cpu information, like usage, model, and more)",
)
parser.add_argument(
    "-nm",
    "--nomem",
    action="store_true",
    help="disables meminfo (memory information, like total, used and more)",
)
parser.add_argument(
    "-nl",
    "--noload",
    action="store_true",
    help="disables loadavg (load times information, including uptime, and more)",
)
parser.add_argument(
    "-np",
    "--nopid",
    action="store_true",
    help="disables procpid (shows the most vmrss consuming processes)",
)
parser.add_argument(
    "-nn",
    "--nonet",
    action="store_true",
    help="disables network_stats (network stats, like received/transfered bytes, and more)",
)
parser.add_argument(
    "-nt",
    "--notemp",
    action="store_true",
    help="disables cpu temperature",
)
parser.add_argument(
    "-p",
    "--procs",
    type=int,
    default=6,
    metavar="INT",
    help="how many processes to show in procpid. Default: 6",
)
parser.add_argument(
    "-s",
    "--sleep",
    type=float,
    default=1,
    metavar="FLOAT",
    help="refresh time. Default: 1.0",
)

args = parser.parse_args()

# sysmon basic functions start


def char_padding(char, value):
    """
    return char value times
    """
    return char * value


def convert_bytes(fsize, units=(" bytes", " KiB", " MiB", " GiB", " TiB")):
    """convert bytes to k, m, g and t"""
    for unit in units:
        if fsize < 1024:
            return f"{fsize:.2f}{unit}"
        fsize /= 1024
    return f"{fsize:.2f} {units[-1]}"


def en_open(file, method="r"):
    """modifying the default open method so i dont have to define encoding every time"""
    return open(file, mode=method, encoding="utf-8")


def detect_network_adapter():
    """detect an active network adapter/card/whatever and return its directory"""
    for adapter_dir in glob.glob("/sys/class/net/*"):
        with en_open(adapter_dir + "/type") as device_type:
            if int(device_type.read()) != 772:  # if not loopback device
                with en_open(adapter_dir + "/operstate") as status:
                    if status.read().strip() == "up":
                        return adapter_dir
    return None


def file_has(string, lines):
    """checking if file contains string. return string if contains else return None"""
    for line in lines:
        if line.startswith(string):
            return line.strip().split(":")[1]
    return None


def clean_output(text):
    """
    cleans the output that sysmon reads, so it gets only 1005744
    instead of MemTotal:        1005744 kB
    """
    return text.split(":")[0].strip().replace("kB", "")


def to_bytes(kilobytes):
    """convert kilobytes to bytes"""
    return kilobytes * 1024


def uptime_format(seconds):
    """format the uptime from seconds to a human readable format"""
    intervals = (("week", 604800), ("day", 86400), ("hour", 3600), ("minute", 60))
    result = []

    if seconds < 60:
        return f"{seconds} seconds"

    for name, count in intervals:
        value = seconds // count

        if value:
            seconds -= value * count
            result.append(f"{value} {name if value == 1 else name + 's'}")

    if len(result) > 1:
        result[-1] = "and " + result[-1]

    return ", ".join(result)


def clean_cpu_model(model):
    """cleaning cpu model"""
    replace_stuff = [
        "(R)",
        "(TM)",
        "(tm)",
        "Processor",
        "processor",
        '"AuthenticAMD"',
        "Chip Revision",
        "Technologies, Inc",
        "CPU",
        "with Radeon HD Graphics",
    ]
    for text in replace_stuff:
        model = model.replace(text, "")

    return " ".join(model.split()).split("@", maxsplit=1)[0].rstrip(" ")


# sysmon basic functions end

# sysmon cpu


def cpu_usage():
    """
    /proc/stat - cpu usage of the system
    """

    try:
        if not os.path.exists(SAVE_DIR + "/cpu_old_data"):
            with en_open(SAVE_DIR + "/cpu_old_data", "a") as temp_file:
                temp_file.write("cpu.758102.17.259220.2395399.122421.3.1284")

        with en_open(SAVE_DIR + "/cpu_old_data") as old_stats:
            old_stats = old_stats.readline().split(".")
            previous_data = (
                int(old_stats[1])
                + int(old_stats[2])
                + int(old_stats[3])
                + int(old_stats[6])
                + int(old_stats[7])
            )

        with en_open("/proc/stat") as new_stats:
            new_stats = new_stats.readline().replace("cpu ", "cpu").strip().split(" ")

            current_data = (
                int(new_stats[1])
                + int(new_stats[2])
                + int(new_stats[3])
                + int(new_stats[6])
                + int(new_stats[7])
            )

        total = sum(map(int, old_stats[1:])) - sum(map(int, new_stats[1:]))

        with en_open(SAVE_DIR + "/cpu_old_data", "w") as update_data:
            update_data.write(".".join(new_stats))

        try:
            return round(100 * ((previous_data - current_data) / total))

        except ZeroDivisionError:  # there should be a better way (or maybe thats the only way)
            return 0

    except FileNotFoundError:
        sys.exit("Couldnt find /proc/stat file")

    except PermissionError:
        sys.exit(
            "Couldnt read the file. Do you have read permissions for /proc/stat file?"
        )


def cpu_temp(hwmon_dirs):
    """
    getting the cpu temperature from /sys/class/hwmon
    """

    temperature = "!?"

    for temp_dir in hwmon_dirs:
        with en_open(temp_dir + "/name") as temp_type:
            if (temp_type.read() in "coretemp", "fam15h_power", "k10temp", "acpitz"):
                try:
                    with en_open(temp_dir + "/temp1_input") as temp_value:
                        temperature = int(temp_value.readline().strip()) // 1000
                        break

                except (FileNotFoundError, OSError):
                    pass

    return temperature


def cpuinfo():
    """
    /proc/cpuinfo - cpu information
    """

    try:
        with en_open("/proc/cpuinfo") as cpuinfo_file:
            cpu_freq = "Unknown"
            model = "Unknown"
            cache_size = "0"
            architecture = platform.machine()

            for line in cpuinfo_file:
                if line.startswith("cpu MHz"):
                    cpu_freq = line.split(":")[1].strip()

                elif line.startswith("model name"):
                    model = clean_cpu_model(line.split(":")[1].strip())
                    model = model if len(model) < 25 else model[:25] + "..."

                elif line.startswith("cache size"):
                    cache_size = line.split(":")[1].strip().replace("KB", "")

                elif line.startswith("Hardware") and architecture in (
                    "aarch64",
                    "armv7l",
                ):
                    model = clean_cpu_model(line.split(":")[1].strip())

            total_cores = os.cpu_count() or "Unknown"
            total_threads = multiprocessing.cpu_count()

            cpu_usage_num = cpu_usage()
            cpu_temperature = str(cpu_temp(hwmon_dirs_out))

            if cpu_temperature != "!?" and not args.notemp:
                cpu_temperature += " Â°C"
                arch_model_temp_line = f"({cpu_temperature}) | {architecture} {model}"

            else:
                arch_model_temp_line = f"| {architecture} {model}"

            cache_memory = convert_bytes(to_bytes(int(cache_size))) + " cache memory"

        return (
            f"  --- /proc/cpuinfo {char_padding('-', 47)}\n"
            f"{char_padding(' ', 11)}Usage: {cpu_usage_num}% "
            + " " * (3 - len(str(cpu_usage_num)))
            + arch_model_temp_line
            + "\n"
            f"   Cores/Threads: {total_cores}/{total_threads} @ {cpu_freq} MHz"
            f" with {cache_memory}\n"
        )

    except FileNotFoundError:
        sys.exit("Couldnt find /proc/cpuinfo file")

    except PermissionError:
        sys.exit(
            "Couldnt read the file. Do you have read permissions for /proc/meminfo file?"
        )


# sysmon cpu

# sysmon meminfo


def meminfo():
    """
    /proc/meminfo - system memory (ram) and swap information
    """

    try:
        with en_open("/proc/meminfo") as meminfo_file:
            meminfo_data = meminfo_file.readlines()

            memory_total = to_bytes(
                int(clean_output(file_has("MemTotal", meminfo_data)))
            )
            memory_available = to_bytes(
                int(clean_output(file_has("MemAvailable", meminfo_data)))
            )
            memory_cached = to_bytes(
                int(clean_output(file_has("Cached", meminfo_data)))
                + int(clean_output(file_has("SReclaimable", meminfo_data)))
                - int(clean_output(file_has("Shmem", meminfo_data)))
            )

            memory_used = round(memory_total - memory_available)
            memory_actual_used = (
                round(
                    memory_total
                    - to_bytes(int(clean_output(file_has("MemFree", meminfo_data))))
                    - to_bytes(int(clean_output(file_has("Buffers", meminfo_data))))
                )
                - memory_cached
            )

            memory_used_percent = round((int(memory_used) / int(memory_total)) * 100, 1)
            memory_actual_used_percent = round(
                (int(memory_actual_used) / int(memory_total)) * 100, 1
            )
            memory_available_percent = round(100 - memory_used_percent, 1)

            if to_bytes(int(clean_output(file_has("SwapTotal", meminfo_data)))) != 0:
                swap_total = to_bytes(
                    int(clean_output(file_has("SwapTotal", meminfo_data)))
                )
                swap_available = to_bytes(
                    int(clean_output(file_has("SwapFree", meminfo_data)))
                )
                swap_cached = to_bytes(
                    int(clean_output(file_has("SwapCached", meminfo_data)))
                )

                swap_used = round(swap_total - swap_available)

                swap_used_percent = round((int(swap_used) / int(swap_total)) * 100, 1)
                swap_available_percent = round(100 - swap_used_percent, 1)

                memory_used_format = (
                    f"{convert_bytes(memory_used)} ({memory_used_percent}%)"
                )
                memory_avail_format = (
                    f"{convert_bytes(memory_available)} "
                    f"({memory_available_percent}%)"
                )

                spaces_swap = (
                    25
                    if str(convert_bytes(swap_total)).split(" ")[1] == "GiB"
                    else 23
                    if str(convert_bytes(swap_total)).split(" ")[1] == "TiB"
                    and str(convert_bytes(memory_total)).split(" ")[1] == "TiB"
                    else 22
                    if str(convert_bytes(swap_total)).split(" ")[1] == "TiB"
                    else 25
                )

                return (
                    f"  --- /proc/meminfo {char_padding('-', 47)}\n"
                    f"   RAM: {char_padding(' ', 25)} Swap:\n"
                    f"        Total: {convert_bytes(memory_total)}"
                    + char_padding(" ", (spaces_swap - len(convert_bytes(swap_total))))
                    + f"Total: {convert_bytes(swap_total)}\n"
                    f"         Used: {memory_used_format}"
                    + char_padding(" ", (26 - len(memory_used_format)))
                    + f"Used: {convert_bytes(swap_used)} ({swap_used_percent}%)\n"
                    f"  Actual Used: {convert_bytes(memory_actual_used)} ({memory_actual_used_percent}%)\n"
                    f"    Available: {memory_avail_format}"
                    + char_padding(" ", (21 - len(memory_avail_format)))
                    + f"Available: {convert_bytes(swap_available)} ({swap_available_percent}%)\n"
                    f"       Cached: {convert_bytes(memory_cached)}"
                    + char_padding(" ", (24 - len(convert_bytes(memory_cached))))
                    + f"Cached: {convert_bytes(swap_cached)}\n"
                )

            return (
                f"  --- /proc/meminfo {char_padding('-', 47)}\n"
                f"   RAM: {char_padding(' ', 25)} Swap: Disabled or not available\n"
                f"        Total: {convert_bytes(memory_total)}\n"
                f"         Used: {convert_bytes(memory_used)} ({memory_used_percent}%)\n"
                f"  Actual Used: {convert_bytes(memory_actual_used)} ({memory_actual_used_percent}%)\n"
                f"    Available: {convert_bytes(memory_available)} ({memory_available_percent}%)\n"
                f"       Cached: {convert_bytes(memory_cached)}\n"
            )

    except FileNotFoundError:
        sys.exit("Couldnt find /proc/meminfo file")

    except PermissionError:
        sys.exit(
            "Couldnt read the file. Do you have read permissions for /proc/meminfo file?"
        )


# sysmon meminfo

# sysmon loadavg


def loadavg():
    """
    /proc/loadavg - system load times and uptime
    """

    try:
        with en_open("/proc/loadavg") as loadavg_file, en_open(
            "/proc/uptime"
        ) as uptime_file:
            loadavg_data = loadavg_file.read().split()
            onemin, fivemin, fiveteenmin = loadavg_data[:3]
            entities_active, entities_total = loadavg_data[3].split("/")

            uptime_secs = int(float(uptime_file.read().split()[0]))
            uptime_fmt = uptime_format(uptime_secs)

            up_since_fmt = datetime.fromtimestamp(time.time() - uptime_secs).strftime(
                "%A %B %d %Y, %I:%M:%S %p"
            )

        return (
            f"  --- /proc/loadavg {char_padding('-', 47)}\n"
            f"   System load: {onemin}, {fivemin}, {fiveteenmin} (1, 5, 15 mins)\n"
            f"      Entities: {entities_active} executing, {entities_total} total"
            f"\n\n   System up for {uptime_fmt}\n    Since {up_since_fmt}\n"
        )

    except FileNotFoundError:
        sys.exit("Couldn't find /proc/loadavg file")

    except PermissionError:
        sys.exit(
            "Couldn't read the file. Do you have read permissions for /proc/loadavg file?"
        )


# sysmon loadavg

# sysmon procpid


def procpid():
    """
    return the most ram (vmrss) consuming pids, with their state and name
    """

    processes = []

    for entry_dir in os.scandir("/proc"):
        if entry_dir.is_dir() and entry_dir.name.isdigit():
            try:
                with en_open(
                    os.path.join(entry_dir.path, "status"), "r"
                ) as status_file:
                    s_readlines = status_file.readlines()

                    pid_name = None
                    pid_num = entry_dir.name
                    rss = None
                    state = None

                    pid_name_line = next(
                        (line for line in s_readlines if line.startswith("Name:")), None
                    )
                    if pid_name_line:
                        pid_name = pid_name_line.partition(":")[2].strip()

                    rss_line = next(
                        (line for line in s_readlines if line.startswith("VmRSS:")),
                        None,
                    )
                    if rss_line:
                        rss = int(clean_output(rss_line.partition(":")[2].strip()))

                    state_line = next(
                        (line for line in s_readlines if line.startswith("State:")),
                        None,
                    )
                    if state_line:
                        state = state_line.partition("(")[2].partition(")")[0].title()

                    if rss is not None:
                        processes.append((pid_name, to_bytes(rss), state, pid_num))

            except FileNotFoundError:
                processes.append((None, 76328097200209, None, "64"))

    processes.sort(key=lambda a: a[1], reverse=True)

    formatted_data = [
        f"  --- /proc/pid/* {char_padding('-', 49)}\n   Name            PID         RSS            State"
    ]

    for name, rss, pstate, pid in processes[: args.procs]:
        rss_usage = convert_bytes(rss) if rss is not None else "!?"

        formatted_data.append(
            f"   {name or '!?!?'}{char_padding(' ', (15 - len(name or '!?!?')))}"
            f" {pid}{char_padding(' ', (11 - len(pid)))}"
            f" {rss_usage}{char_padding(' ', (14 - len(rss_usage)))} {pstate or '!?!?'}"
        )

    return "\n".join(formatted_data) + "\n"


# sysmon procpid

# sysmon net


def network_stats():
    """
    /sys/class/net/ - network stats, and speed
    """

    adapter_directory = detect_network_adapter()

    if adapter_directory is not None:
        if not os.path.isfile(f"{SAVE_DIR}/rx") and not os.path.isfile(f"{SAVE_DIR}tx"):
            with en_open(f"{SAVE_DIR}/rx", "w") as rx_file:
                rx_file.write("0")

            with en_open(f"{SAVE_DIR}/tx", "w") as tx_file:
                tx_file.write("0")

        with en_open(adapter_directory + "/statistics/rx_bytes") as received:
            received = int(received.read().strip())

        with en_open(adapter_directory + "/statistics/tx_bytes") as transferred:
            transferred = int(transferred.read().strip())

        with en_open(f"{SAVE_DIR}/rx") as recv_speed:
            recv_speed = abs(int(recv_speed.read().strip()) - received)

        with en_open(f"{SAVE_DIR}/tx") as transf_speed:
            transf_speed = abs(int(transf_speed.read().strip()) - transferred)

        with en_open(f"{SAVE_DIR}/rx", "w") as rxsave:
            rxsave.write(str(received))

        with en_open(f"{SAVE_DIR}/tx", "w") as txsave:
            txsave.write(str(transferred))

        human_received = convert_bytes(received)
        human_transferred = convert_bytes(transferred)

        return (
            f"  --- /sys/class/net {char_padding('-', 46)}\n"
            f"        Device: {adapter_directory.split('/')[4]}\n"
            f"      Received: {human_received}"
            + char_padding(" ", (14 - len(human_received)))
            + f"({received} bytes)\n"
            f"   Transferred: {human_transferred}"
            + char_padding(" ", (14 - len(human_transferred)))
            + f"({transferred} bytes)\n"
            f"         Speed: Down {convert_bytes(recv_speed)}"
            + char_padding(" ", (14 - len(convert_bytes(recv_speed))))
            + f"| Up {convert_bytes(transf_speed)}\n"
        )

    return f"  --- /sys/class/net/!?!? {char_padding('-', 41)}\n"


# sysmon net

func_dict = {
    "cpu": cpuinfo,
    "mem": meminfo,
    "load": loadavg,
    "pid": procpid,
    "net": network_stats,
}


def main(stdscr):
    """main printing method, what you see when you run sysmon"""

    stdscr.nodelay(True)

    curses.curs_set(0)
    curses.use_default_colors()

    try:
        while True:
            stdscr.addstr(
                f" --- Sysmon | {datetime.now().strftime('%I:%M:%S %p')} "
                + "-" * 42
                + "\n"
            )

            for name, function in func_dict.items():
                if not getattr(args, "no" + name, False):
                    stdscr.addstr(function())

            stdscr.addstr(f" {'-' * 67}")
            stdscr.refresh()

            rlist = select.select([sys.stdin], [], [], args.sleep)

            if rlist:
                kinput = stdscr.getch()

                if kinput == ord("q"):
                    curses.curs_set(1)
                    break

            stdscr.erase()

    except curses.error:
        sys.exit("Not enough space. Please resize")

    except KeyboardInterrupt:
        curses.endwin()
        curses.curs_set(1)

    curses.endwin()


curses.wrapper(main)
